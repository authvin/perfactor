package helper

import (
	"github.com/google/pprof/profile"
	"sort"
	"time"
)

// This code is generated by ChatGPT, in an experiment to see if it can handle code this complicated
// Another motivation is to give concrete code to work with to give me a better understanding of the pprof format
// I am still unsure if this can or should be used, nor if it has stolen code from somewhere.
// If it has copied code, that needs to be properly credited.
// The code might also not work as intended - that needs to be confirmed as well.

// LineCounter represents the number of times a line of code was
// executed in the program.
type LineCounter struct {
	Line  int64         // line number
	File  string        // file containing the line
	Func  string        // function containing the line
	Count int64         // number of times the line was executed
	Time  time.Duration // time spent executing the line
}

// ByCount is a sort.Interface that sorts line execution counts by their count.
type ByCount []LineCounter

func (a ByCount) Len() int           { return len(a) }
func (a ByCount) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByCount) Less(i, j int) bool { return a[i].Count < a[j].Count }

// ByTime is a sort.Interface that sorts line execution counts by the amount of
// time spent executing each line.
type ByTime []LineCounter

func (a ByTime) Len() int           { return len(a) }
func (a ByTime) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByTime) Less(i, j int) bool { return a[i].Time < a[j].Time }

// getLines returns a list of the lines of code in the program
// sorted by the number of times they were executed.
func getLines(p *profile.Profile) []LineCounter {
	err := p.RemoveUninteresting()
	if err != nil {
		return nil
	}
	err = p.Aggregate(false, true, true, true, false)
	if err != nil {
		return nil
	}
	// Map from (file, func, line) tuple to line execution count.
	counts := make(map[string]map[string]map[int64]LineCounter)
	for _, sample := range p.Sample {
		for _, loc := range sample.Location {
			line := loc.Line[0]
			file := line.Function.Filename
			fn := line.Function.Name
			linenumber := line.Line
			if counts[file] == nil {
				counts[file] = make(map[string]map[int64]LineCounter)
			}
			if counts[file][fn] == nil {
				counts[file][fn] = make(map[int64]LineCounter)
			}
			lc := counts[file][fn][linenumber]
			lc.Count++
			// sample.Value contains the sample count at index 0 and the time at index 1
			// If needed, check the unit in p.PeriodType.Unit (string representation) (usually nanoseconds)
			lc.Time += time.Duration(sample.Value[1])
			counts[file][fn][linenumber] = lc
		}
	}

	// Convert counts map to a slice of LineCounter values.
	var lines []LineCounter
	for file, funcs := range counts {
		for funcname, funcLines := range funcs {
			for line, count := range funcLines {
				count.File = file
				count.Func = funcname
				count.Line = line
				lines = append(lines, count)
			}
		}
	}

	return lines
}

func GetLinesByCount(p *profile.Profile) []LineCounter {
	lines := getLines(p)
	// Sort the lines by the number of times they were executed.
	sort.Sort(sort.Reverse(ByCount(lines)))
	return lines
}

func GetLinesByTime(p *profile.Profile) []LineCounter {
	lines := getLines(p)
	sort.Sort(sort.Reverse(ByTime(lines)))
	return lines
}
